# 이진 탐색 알고리듬

* **정렬된 배열**에서 어떤 값의 위치를 찾는 알고리듬
* 한 단계 진행할 때마다 탐색범위를 절반으로 줄임
  * 이진(binary) 라는 이름이 탄생한 이유
  * 시간복잡도는 O(Log n) ➜ 절반으로 줄이는게 왜 Log n 이냐?  ➜ 2씩 곱해가는건 지수!, 그의 반대는 Log n 
    * (참고) O(Log n)  은 O(1) 보다는 느리고 O(n) 보다는 빠르다.
* 분할 정복(divide-and-conquer) 알고리듬 중 하나
  * 정복이라 하기에는 모든 문제 영역을 방문하지 않음
  * 따라서 decrease-and-conquer 라고 부르자는 소수설도 있음

---

# 정렬된 데이터와 알고리듬

* 정렬된 데이터에 사용할 수 있는 효율적인 알고리듬이 많음
  * 어떤 값의 위치 찾기: O(Log n) ➜ 이진탐색
  * 최솟값/ 최대값 찾기: O(1)
* 정렬되지 않은 배열은?
  * 정렬 알고리듬을 사용하여 정렬 가능
  * 일단 정렬하면 효율적 알고리듬 사용 가능 (**정렬 알고리듬의 중요성**)
  * 하지만 배열에 새 요소를 추가하면 다시 정렬해야 함
    * 정렬 알고리듬이 이진 탐색보다 시간 복잡도가 높음 ➜ O(Log n) 보다도, O(n) 보다도 높음

----

# 정렬 후 이진 탐색 vs. 선형 탐색

| 배열이 안 바뀌는 경우                                        | 배열이 바뀌는 경우                                           |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| * 탐색할 일이 많은 경우<br />정렬 한번 후, 이진 탐색 여러 번<br />O(정렬시간복잡도) + O(Log n) * x | * 요소를 삽입하는 경우만 문제가 됨<br />* 보통 선형 탐색을 사용<br />* 이진 탐색을 사용하려면?<br />1) 탐색 전에 배열을 정렬 해야 함<br />배열이 바뀔 때마다 곧바로..<br />배열이 바뀐 적이 있다면 탐색 직전에..<br />2) 선형 탐색보다 느릴 수 있음<br />탐색과 배열 빈경 변도에 따라..<br />탐색 빈도가 높을수록 유리 |
| * 탐색을 한 번만 할 경우<br />선형 탐색<br />O(n)            |                                                              |

